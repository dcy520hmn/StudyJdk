[TOC]

# 已阅代码清单_按功能排序


|  分级  | 阅读完成度 | 含义 |
| :---: | -------- | ---- |
|   1   | :full_moon: | 完成阅读，方法/字段已读完，实现过程已了解 |
|   2   | :waxing_gibbous_moon: | 完成阅读，方法/字段已读完，但一些实现细节未掌握 |
|   3   | :first_quarter_moon: | 正在阅读，方法/字段未读完，理解了大部分特性 |
|   4   | :waxing_crescent_moon: | 正在阅读，方法/字段未读完，只涉猎了一部分特性 |
|   5   | :new_moon: | 初步接触，有限的了解，大概知道该类的作用 |

* **集合**

  - :first_quarter_moon:[ArrayList](src/java/util/ArrayList.java)

    - 如何扩容的？

      增加原来lenth的1.5倍，最大容量为Inter.maxValue.

    - 

  - :first_quarter_moon:[LinkedList](src/java/util/LinkedList.java)

--------------------------------------------------

- 多线程

  - :first_quarter_moon:TheadLocal

    

  - 

# 功能笔记

## ArrayList



## TheadLocal

这个类提供线程局部变量。这些变量与普通变量的不同之处在于，每个访问一个变量(通过其get或set方法)的线程都有自己的独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，希望将状态与线程关联(例如，用户ID或事务ID)。

### 静态内部类ThreadLocalMap

ThreadLocalMap用来保存线程局部遍历值。只给ThreadLocal服务，不对外提供任何operator。这个类是包私有且允许在Thread类中声明字段。ThreadLocalMap中存在一个Entity[] table 变量，用来存储key-value。Entity使用WeakReferences作为键，但是，由于不使用引用队列，只有当表空间耗尽时，才会删除陈旧的表项。一个线程中有一个ThreadLocalMap，一个ThreadLocalMap中可以存多个Entity【可以存多个key（ThreaLocal）-value】。

### 静态内部类Entry

该类继承了WeakReference，它的主ref字段作为key，此处，ref为ThreadLocal的一个对象。（Entry的key就是ThreadLocal的实例）。

若key为null，则说明该key不再被引用，所以可以在Entity[] table清除掉。key为null的Entry被称为stale entries。

### **ThreadLocal之hashCode计算**

```java
 private final int threadLocalHashCode = nextHashCode();

 private static AtomicInteger nextHashCode = new AtomicInteger();

 //1640531527 这是一个神奇的数字，能够让hash槽位分布相当均匀
 private static final int HASH_INCREMENT = 0x61c88647; 

 private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
 }
```

在 ThreadLocalMap 中 的 hashCode 全部使用 threadLocalHashCode 字段。threadLocalHashCode 用 final 修饰，不可变。threadLocalHashCode 的生成调用 nextHashCode()，所有 ThreadLocalMap 的 hashCode 使用静态的 AtomicInteger 每次增加 1640531527 来产生，对于魔数 1640531527 的工作原理，数学思想比较多，这里写个demo看一下基于这种方式产生的hash分布多均匀：

```java
public class ThreadLocalTest {

    public static void main(String[] args) {
        printAllSlot(8);
        printAllSlot(16);
        printAllSlot(32);
    }

    static void printAllSlot(int len) {
        System.out.println("********** len = " + len + " ************");
        for (int i = 1; i <= 64; i++) {
            ThreadLocal<String> t = new ThreadLocal<>();
            int slot = getSlot(t, len);
            System.out.print(slot + " ");
            if (i % len == 0)
                System.out.println(); // 分组换行
        }
    }

    /**
     * 获取槽位
     * 
     * @param t ThreadLocal
     * @param len 模拟map的table的length
     * @throws Exception
     */
    static int getSlot(ThreadLocal<?> t, int len) {
        int hash = getHashCode(t);
        return hash & (len - 1);
    }

    /**
     * 反射获取 threadLocalHashCode 字段，因为其为private的
     */
    static int getHashCode(ThreadLocal<?> t) {
        Field field;
        try {
            field = t.getClass().getDeclaredField("threadLocalHashCode");
            field.setAccessible(true);
            return (int) field.get(t);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return 0;
    }
}
```

### 阅读过的方法

- `ThreadLocal::set(T value)`

  设置该线程局部变量的值

- `ThreadLocal::createMap(Thread t, T firstValue)`

  调用ThreadLocalMap构造方法初始化ThreadLocalMap

- `ThreadLocalMap::ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue)`

  构建出包含(firstKey, firstValue)的Map。

- `ThreadLocalMap::set(ThreadLocal<?> key, Object value)`

  给当前key设置值

- `ThreadLocalMap::replaceStaleEn`try(ThreadLocal<?> key, Object value,`
                                 int staleSlot)`

  在集合操作期间，用一个具体key的entry替换掉stale entry（key为null的entry），无论是否存在具体key的entry，都会value存到entry中。副作用为：会清除run中所有的stale entry。run：table中两个null之间的序列。

